#
# ~/.zshrc
#

# force locale
export LANG=en_US.UTF-8
export LANGUAGE=en_US

# use emacs-like key bindings
bindkey -e

# {{{ utility functions
__source() {
	[[ -f $1 ]] && . "$1"
}
__prepend_path() {
	path=($1 $path)
}
__prepend_path_with_check() {
	[[ -d $1 ]] && __prepend_path "$1"
}
# }}}

# {{{ command history
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=50000
HISTORY_IGNORE="((la|ll|ls|lla|popd)|(cd|la|ll|ls|lla|man|scp|sftp|ssh|sudo|rm) *)"
zshaddhistory() {
	whence ${${(z)1}[1]} >| /dev/null || return 1
}
setopt hist_ignore_dups
setopt hist_ignore_all_dups
setopt hist_ignore_space
setopt hist_no_store
setopt hist_reduce_blanks
setopt hist_save_no_dups
setopt share_history
# }}}

# {{{ miscellaneous
setopt autocd
setopt auto_pushd
setopt pushd_ignore_dups

setopt no_beep

setopt correct

autoload -Uz select-word-style && select-word-style bash
# }}}

# {{{ aliases
alias ls='ls -h --color=auto'
alias la='ls -A'
alias ll='ls -l'
alias lla='ls -lA'

alias grep='grep --color=auto'
alias diff='diff --color=auto'

alias mkdir='mkdir -p'

export LESS=-R
export LESS_TERMCAP_mb=$'\E[1;31m'     # begin blink
export LESS_TERMCAP_md=$'\E[1;36m'     # begin bold
export LESS_TERMCAP_me=$'\E[0m'        # reset bold/blink
export LESS_TERMCAP_so=$'\E[01;44;33m' # begin reverse video
export LESS_TERMCAP_se=$'\E[0m'        # reset reverse video
export LESS_TERMCAP_us=$'\E[1;32m'     # begin underline
export LESS_TERMCAP_ue=$'\E[0m'        # reset underline
export LESSHISTFILE=-

alias v='nvim'
# }}}

# {{{ syntax highlight
() {
	local highlight_src=/usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
	__source "$highlight_src"
	typeset -A ZSH_HIGHLIGHT_STYLES
	ZSH_HIGHLIGHT_STYLES[globbing]='none'
	ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
}
# }}}

# {{{ prompt
autoload -Uz colors
colors

setopt prompt_subst
() {
	PROMPT=$'\n''[%{$fg_bold[magenta]%}%n@%m%{$reset_color%}:%{$fg_bold[cyan]%}%c%{$reset_color%}]'

	local git_ps1_src=/usr/share/git/completion/git-prompt.sh
	__source "$git_ps1_src" && PROMPT="$PROMPT"'$(__git_ps1 "(%s)")'
	GIT_PS1_SHOWDIRTYSTATE=1
	GIT_PS1_SHOWUNTRACKEDFILES=1
	PROMPT="$PROMPT"$'\n''%# '
}
# }}}

# {{{ setup asdf
if [[ -d ~/.asdf ]]; then
	__source ~/.asdf/asdf.sh
	fpath=(~/.asdf/completions $fpath)
fi
# }}}

# {{{ PATH setting
[[ -d ~/.local/flutter ]] && __prepend_path ~/.local/flutter/default/bin
[[ -d ~/.local/texlive ]] && __prepend_path ~/.local/texlive/default/bin/x86_64-linux
hash go 2>/dev/null && __prepend_path "$(go env GOPATH)/bin"
__prepend_path_with_check ~/.local/bin
# }}}

# {{{ auto completion
fpath=(~/.zfunc ~/.zsh/completions $fpath)
autoload -Uz compinit && compinit
# force evaluate completion of pip
hash pip 2>/dev/null && eval "$(pip completion --zsh)"
# }}}

# {{{ key setting
() {
	local -A key
	key[Home]=${terminfo[khome]}
	key[End]=${terminfo[kend]}
	key[PgUp]=${terminfo[kpp]}
	key[PgDn]=${terminfo[knp]}
	key[Up]=${terminfo[kcuu1]}
	key[Down]=${terminfo[kcud1]}
	key[Left]=${terminfo[kcub1]}
	key[Right]=${terminfo[kcuf1]}
	key[Ins]=${terminfo[kich1]}
	key[Del]=${terminfo[kdch1]}
	key[CLeft]=${terminfo[kLFT5]}
	key[CRight]=${terminfo[kRIT5]}
	key[CDel]=${terminfo[kDC5]}

	[[ -n ${key[Home]} ]] && bindkey -- "${key[Home]}" beginning-of-line
	[[ -n ${key[End]} ]] && bindkey -- "${key[End]}" end-of-line
	[[ -n ${key[PgUp]} ]] && bindkey -- "${key[PgUp]}" beginning-of-buffer-or-history
	[[ -n ${key[PgDn]} ]] && bindkey -- "${key[PgDn]}" end-of-buffer-or-history
	[[ -n ${key[Up]} ]] && bindkey -- "${key[Up]}" up-line-or-history
	[[ -n ${key[Down]} ]] && bindkey -- "${key[Down]}" down-line-or-history
	[[ -n ${key[Left]} ]] && bindkey -- "${key[Left]}" backward-char
	[[ -n ${key[Right]} ]] && bindkey -- "${key[Right]}" forward-char
	# [[ -n ${key[Ins]} ]] && bindkey -- "${key[Ins]}" overwrite-char
	[[ -n ${key[Del]} ]] && bindkey -- "${key[Del]}" delete-char
	[[ -n ${key[CLeft]} ]] && bindkey -- "${key[CLeft]}" backward-word
	[[ -n ${key[CRight]} ]] && bindkey -- "${key[CRight]}" forward-word
	[[ -n ${key[CDel]} ]] && bindkey -- "${key[CDel]}" delete-word

	if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
		zle-line-init() {
			printf '%s' "${terminfo[smkx]}"
		}
		zle-line-finish() {
			printf '%s' "${terminfo[rmkx]}"
		}
		zle -N zle-line-init
		zle -N zle-line-finish
	fi
}

bindkey "^U" backward-kill-line
# }}}

# {{{ load functions
() {
	for f in ~/.zsh/functions/*.zsh; do
		__source "$f"
	done
}
# }}}
